# 缓存增量刷新机制（优化版）

## 概述

为了解决高并发场景下缓存一致性和性能的平衡问题，实现了基于时间戳的增量刷新机制。只刷新最近更新的数据，大幅减少数据库查询量，同时确保数据一致性。

## 核心优化策略

### 1. 增量更新机制

**原理：**
- 使用 `update_datetime` 字段追踪数据变化
- 只查询最近更新的数据（默认查询最近2秒内更新的）
- 在 Redis 中存储每个数据的最后更新时间戳
- 通过时间戳比较，跳过未变化的数据

**优势：**
- 大幅减少数据库查询量（从全量查询到只查询变化的数据）
- 减少 Redis 写入压力
- 保持数据一致性（最多1秒延迟）

### 2. 刷新策略

#### 初始化阶段（全量刷新）
- 服务启动时执行一次全量刷新
- 确保所有数据都有缓存

#### 运行阶段（增量刷新）
- 每秒执行一次增量刷新
- 只查询 `update_datetime > lastRefreshTime` 的数据
- 通过时间戳比较，跳过未变化的数据

### 3. 时间戳管理

**存储机制：**
- 每个缓存项对应一个时间戳键：`{cacheKey}:update_time`
- 时间戳使用 RFC3339Nano 格式存储
- 与数据缓存使用相同的过期时间

**比较逻辑：**
```go
// 如果数据库中的更新时间 <= 缓存中的时间，跳过更新
if cachedTime != nil && !dbUpdateTime.After(*cachedTime) {
    continue // 跳过，数据未变化
}
```

## 性能优化效果

### 优化前（全量刷新）
- 每次刷新：查询所有商户、租户、渠道、插件等
- 假设有 1000 个商户、100 个渠道、50 个插件
- 每次刷新：1150+ 条数据库查询
- 每秒：1150+ 次查询

### 优化后（增量刷新）
- 每次刷新：只查询最近2秒内更新的数据
- 假设每秒只有 1-2 条数据更新
- 每次刷新：1-2 条数据库查询
- 每秒：1-2 次查询

**性能提升：** 减少 99%+ 的数据库查询量

## 实现细节

### 刷新窗口

```go
refreshWindow: 2 * time.Second  // 查询最近2秒内更新的数据
```

**为什么是2秒？**
- 1秒刷新间隔 + 1秒缓冲 = 2秒窗口
- 确保不会遗漏任何更新
- 即使数据库时间略有偏差也能覆盖

### 时间戳缓冲

```go
s.lastRefreshTime = now.Add(-500 * time.Millisecond) // 留500ms缓冲
```

**作用：**
- 避免因时间精度问题遗漏数据
- 确保数据一致性

### 关键数据优先

对于关键业务数据（支付渠道、插件），采用更严格的刷新策略：
- 即使时间戳相同，也会检查状态字段
- 确保禁用/启用状态能及时更新

## 数据一致性保证

### 1. 时间戳机制
- 使用数据库的 `update_datetime` 字段
- 每次更新数据时，数据库自动更新该字段
- 缓存刷新时比较时间戳，只更新变化的数据

### 2. 全量初始化
- 服务启动时执行一次全量刷新
- 确保所有数据都有初始缓存

### 3. 容错机制
- 如果 `update_datetime` 为 NULL，视为需要刷新
- 如果时间戳比较失败，默认刷新数据
- 确保不会因为时间戳问题导致数据不一致

## 使用场景

### 场景 1：后台禁用支付渠道

1. 后台更新 `dvadmin_pay_channel` 表，`update_datetime` 自动更新
2. 1秒内，缓存刷新服务检测到 `update_datetime` 变化
3. 查询该渠道的最新数据并更新缓存
4. 下次下单时，从缓存获取到最新的禁用状态

### 场景 2：批量更新

如果后台批量更新多条数据：
- 每条数据的 `update_datetime` 都会更新
- 刷新服务会检测到所有变化的数据
- 批量更新缓存

## 监控建议

建议监控以下指标：

1. **刷新数据量**：每次刷新更新的数据条数
2. **查询命中率**：有变化的数据 / 总数据
3. **刷新耗时**：每次刷新的执行时间
4. **数据库查询数**：每秒的数据库查询次数

## 配置调优

### 调整刷新窗口

如果数据更新频率很低，可以增大刷新窗口：

```go
refreshWindow: 5 * time.Second  // 查询最近5秒内更新的数据
```

### 调整刷新间隔

如果对实时性要求不高，可以降低刷新频率：

```go
ticker := time.NewTicker(5 * time.Second) // 每5秒刷新一次
```

### 分层刷新策略

对于不同类型的数据，可以使用不同的刷新策略：

```go
// 关键数据（渠道、插件）：每秒刷新
// 非关键数据（商户、租户）：每5秒刷新
```

## 注意事项

1. **数据库时间同步**：确保数据库服务器时间准确
2. **时区问题**：确保应用和数据库使用相同的时区
3. **NULL 处理**：`update_datetime` 为 NULL 的数据会每次刷新
4. **性能监控**：监控数据库查询量，确保优化效果

## 故障处理

### 问题：数据更新后缓存未刷新

**可能原因：**
1. `update_datetime` 未正确更新
2. 时间戳比较逻辑有问题
3. Redis 连接问题

**解决方案：**
1. 检查数据库 `update_datetime` 字段是否正确更新
2. 检查日志，查看是否有刷新错误
3. 可以临时执行全量刷新（重启服务）

### 问题：数据库查询量仍然很大

**可能原因：**
1. 数据更新频率很高
2. 很多数据的 `update_datetime` 为 NULL

**解决方案：**
1. 检查数据更新频率
2. 为 NULL 的 `update_datetime` 设置默认值
3. 考虑使用版本号机制替代时间戳

## 未来优化方向

1. **版本号机制**：使用版本号替代时间戳，更精确
2. **事件驱动**：通过消息队列接收数据变更事件
3. **智能刷新**：根据数据变化频率动态调整刷新策略
4. **分布式锁**：多实例部署时，使用分布式锁避免重复刷新

