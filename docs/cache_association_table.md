# 关联表缓存刷新策略

## 问题描述

某些关联表（如 `dvadmin_pay_plugin_pay_types`）没有 `update_datetime` 字段，无法直接通过时间戳判断是否需要刷新缓存。

## 解决方案

采用**多重策略组合**的方式，确保关联表数据的一致性：

### 策略 1：监听父表变化

**当插件（PayPlugin）更新时：**
- 检测到插件 `update_datetime` 变化
- 自动刷新该插件的所有支付类型关联

**当支付类型（PayType）更新时：**
- 检测到支付类型 `update_datetime` 变化
- 查找所有使用该支付类型的插件
- 刷新这些插件的支付类型关联

### 策略 2：哈希值检测（备用）

**原理：**
- 计算关联关系的哈希值（基于支付类型ID列表）
- 将哈希值存储在 Redis 中
- 每次刷新时比较哈希值，如果不同则刷新

**适用场景：**
- 直接修改关联表（增删关联关系）
- 父表未更新但关联关系变化的情况

### 策略 3：全量初始化

**服务启动时：**
- 全量刷新所有插件的支付类型关联
- 确保所有数据都有初始缓存和哈希值

## 实现细节

### 哈希值计算

```go
// 对支付类型ID列表排序，确保哈希值稳定
sorted := sort(payTypeIDs)

// 生成字符串： "1,2,3,"
hashStr := join(sorted, ",")

// 使用 MD5 生成固定长度的哈希值
hash := MD5(hashStr)
```

**优势：**
- 稳定：相同关联关系生成相同哈希值
- 高效：MD5 计算快速
- 可靠：能检测到任何关联关系变化

### 刷新流程

```
1. 检查有更新的插件 → 添加到刷新列表
2. 检查有更新的支付类型 → 查找相关插件 → 添加到刷新列表
3. 对于刷新列表中的插件：
   - 查询最新的支付类型关联
   - 计算哈希值
   - 与缓存中的哈希值比较
   - 如果不同，更新缓存和哈希值
```

## 性能优化

### 批量查询

```go
// 批量查询所有相关插件的关联关系
database.DB.Table("dvadmin_pay_plugin_pay_types").
    Where("paytype_id IN ?", updatedPayTypeIDs).
    Pluck("payplugin_id", &relatedPluginIDs)
```

**优势：**
- 一次查询获取所有相关插件ID
- 避免循环查询

### 去重处理

```go
pluginIDsToRefresh := make(map[int64]bool)
// 使用 map 自动去重
```

**优势：**
- 避免重复刷新同一个插件
- 减少不必要的数据库查询

## 数据一致性保证

### 场景 1：后台修改插件

1. 后台更新插件信息 → `update_datetime` 更新
2. 刷新服务检测到插件更新
3. 刷新该插件的支付类型关联
4. 更新缓存和哈希值

### 场景 2：后台修改支付类型

1. 后台更新支付类型 → `update_datetime` 更新
2. 刷新服务检测到支付类型更新
3. 查找所有使用该支付类型的插件
4. 刷新这些插件的支付类型关联

### 场景 3：直接修改关联表

1. 后台直接增删关联关系
2. 如果父表未更新，通过哈希值检测
3. 比较当前关联关系的哈希值与缓存中的哈希值
4. 如果不同，刷新缓存

## 注意事项

### 1. 父表更新机制

**最佳实践：**
- 后台修改关联关系时，同时更新父表的 `update_datetime`
- 例如：添加插件支付类型关联时，更新插件的 `update_datetime`

**Python Django 示例：**

```python
# 添加关联关系时，同时更新插件
plugin_pay_type = PayPluginPayType.objects.create(
    payplugin_id=plugin_id,
    paytype_id=paytype_id
)
# 更新插件的 update_datetime
PayPlugin.objects.filter(id=plugin_id).update(update_datetime=now())
```

### 2. 哈希值存储

- 哈希值存储在 Redis 中：`{cacheKey}:hash`
- 与数据缓存使用相同的过期时间
- 如果哈希值丢失，会在下次刷新时重新计算

### 3. 性能考虑

- 哈希值检测主要用于备用场景
- 正常情况下，通过策略1和2已经可以覆盖大部分场景
- 哈希值检测只在增量刷新时对特定插件执行

## 其他关联表的处理

对于其他没有 `update_datetime` 的关联表，可以采用相同的策略：

1. **监听父表变化**：当父表更新时，刷新关联表缓存
2. **哈希值检测**：使用哈希值检测关联关系变化
3. **全量初始化**：服务启动时全量刷新

## 监控建议

建议监控以下指标：

1. **刷新触发源**：统计通过策略1、2、3触发的刷新次数
2. **哈希值变化**：统计哈希值检测到的变化次数
3. **刷新效率**：每次刷新更新的插件数量

