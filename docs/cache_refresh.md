# 缓存自动刷新机制

## 概述

为了解决后台管理系统更新数据后，Go 服务缓存无法及时感知的问题，实现了每秒自动从数据库查询并更新热点数据缓存的机制。

## 工作原理

### 定时刷新

系统启动后，会在后台启动一个 goroutine，每秒执行一次以下操作：

1. 从数据库查询所有热点数据
2. 更新 Redis 缓存
3. 确保缓存数据与数据库保持同步

### 刷新的热点数据

以下数据会每秒自动刷新：

- **商户信息** (`merchant:*`)
- **租户信息** (`tenant:*`)
- **支付渠道** (`channel:*`)
- **插件信息** (`plugin:*`)
- **插件配置** (`plugin_config:*`)
- **插件支付类型** (`plugin_pay_types:*`)

### 缓存过期时间

- 商户、租户、渠道、插件：24 小时
- 用户：1 小时（可选，默认不刷新）

## 实现细节

### 服务启动

在 `main.go` 中，服务启动时会自动启动缓存刷新服务：

```go
// 启动缓存刷新服务（每秒刷新一次热点数据）
cacheRefreshService := service.NewCacheRefreshService()
refreshCtx := context.Background()
go cacheRefreshService.Start(refreshCtx)
logger.Logger.Info("缓存刷新服务已启动（每秒刷新一次热点数据）")
```

### 刷新流程

1. **立即执行**：服务启动时立即执行一次刷新
2. **定时执行**：之后每秒执行一次刷新
3. **优雅关闭**：收到停止信号时优雅关闭

### 性能考虑

- **批量查询**：使用 `Find()` 批量查询所有数据，减少数据库查询次数
- **静默错误**：刷新失败时静默处理，不影响主业务流程
- **独立 goroutine**：在独立的 goroutine 中运行，不阻塞主服务

## 优势

1. **实时性**：后台更新数据后，最多 1 秒内缓存就会更新
2. **自动化**：无需手动清除缓存，系统自动维护
3. **可靠性**：即使刷新失败，也不会影响主业务流程
4. **性能优化**：批量查询和更新，减少数据库压力

## 注意事项

1. **数据库压力**：每秒查询所有热点数据，会增加数据库查询压力
   - 如果数据量很大，可以考虑：
     - 只刷新活跃的数据
     - 降低刷新频率（如每 5 秒或 10 秒）
     - 使用增量更新机制

2. **Redis 压力**：频繁更新缓存会增加 Redis 写入压力
   - 当前实现使用批量更新，影响较小

3. **数据一致性**：虽然每秒刷新，但仍可能存在短暂的数据不一致
   - 对于关键业务（如下单），建议在验证时强制从数据库读取

## 配置建议

### 高并发场景

如果数据量很大，可以考虑调整刷新频率：

```go
// 在 cache_refresh.go 中修改
ticker := time.NewTicker(5 * time.Second) // 改为每 5 秒刷新一次
```

### 数据量大的场景

如果某个表的数据量特别大，可以考虑只刷新活跃数据：

```go
// 只刷新最近更新的数据
func (s *CacheRefreshService) refreshMerchants(ctx context.Context) {
    var merchants []models.Merchant
    // 只查询最近更新的商户
    if err := database.DB.Where("update_datetime > ?", time.Now().Add(-1*time.Hour)).
        Find(&merchants).Error; err != nil {
        return
    }
    // ... 更新缓存
}
```

## 监控建议

建议监控以下指标：

1. **刷新耗时**：每次刷新的执行时间
2. **刷新频率**：实际刷新间隔
3. **数据库查询数**：每秒的数据库查询次数
4. **Redis 写入数**：每秒的 Redis 写入次数

## 故障处理

如果刷新服务出现问题：

1. **检查日志**：查看是否有错误日志
2. **检查数据库连接**：确保数据库连接正常
3. **检查 Redis 连接**：确保 Redis 连接正常
4. **重启服务**：如果问题持续，可以重启服务

## 未来优化

可以考虑的优化方向：

1. **增量更新**：只更新变化的数据
2. **智能刷新**：根据数据变化频率调整刷新间隔
3. **分布式锁**：多实例部署时，使用分布式锁避免重复刷新
4. **事件驱动**：通过消息队列接收数据变更事件，触发刷新

